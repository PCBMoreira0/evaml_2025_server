☐ @low  Adicionar a variável debug on ou off na classe memória.
    1. Isso deve permitir que o usuário, por linha de comando defina se os comandos <debug> no script serão executados.
    2. Dentro do módulo debug deve-se verificar se a variável está em on ou off. Se estiver em off, o módulo retorna sem executar.

☐ @high  Preciso que os valores de dollar e var, tanto de leitura quanto de saída, sejam acessados pelos getters e setters da classe robot_memory e não diretamente na variável.

☐ @low  Preciso verificar as classes, suas interações e formas de representação no diagrama UML do Draw.io.

☐ @low  Terminar os módulos para o EVA e copiar para o FRED.

☐ @high Preciso terminar a parte do módulo de áudio que envia para o simulador e o robot. 

☐ @high Preciso terminar a parte do módulo talk que envia para o simulador e o robot. Ver também a parte de idioma da fala.

☐ @critical Preciso que perimitir a subscrição com base no basetopic (SIMULATOR ou ROBOT).
    1. Até agora, a subscrição está sempre com base_topic = "EVA".
    2. Assim, quando no simulador, os comandos de desbloqueio estão enviando para base_topic = EVA.
    3. No momento da subscrição, na criação da instancia pub_sub de comunicação, preciso saber qual o base_topic. Talvez seja necessário passar a "memória" no construtor.
    4. O problema é que na hora da instanciação (no carregamento dos módulos) ainda não sabemos em modo o usuário vai executar o script.

✔ @high  Executei um script 3x em 3 modos e a memória (com os dólares) não está resetando à cada execução. @done (04/10/2025, 21:10:28)

✔ Corrigir o problema que está dando nas comparações. Revisar o <switch>, o <case> e o <default>. @done (13/09/2025, 15:50:35) @done

✔ Mudar a unidade default do comando <wait> de milissegundos para segundos. @low @done (13/09/2025, 17:30:40)

✔ Definir os setters e getters da classe Robot memory. @done (15/09/2025, 13:11:21)

✔ Implementar a memória do robô no padrão singleton. @high @done (15/09/2025, 13:11:28)

✔ Resolver a questão do cliente mqtt para o comando <log>. @high @done (23/09/2025, 20:09:17)

✔ Resolver a questão do cliente mqtt para o comando <mqtt>. @high @done (23/09/2025, 20:09:19)

✔ A utilização da classe robot memory no padrão singleton foi cancelada... @done (15/09/2025, 13:48:35)

✔ Adicionar o comando <debug> na EvaML. A ideia é que ele tenha um atributo (operation) que defina a sua função.@high @done (04/10/2025, 15:44:27)
    1. Ele poderá pausar o script e aguardar o pressionar de alguma tecla.
    2. Ele poderá exibir no terminal os valores das variaveis na memória.

✔ @high  Preciso verificar porque, algumas vezes, a mensagem mqtt do <log> não vai. @done (04/10/2025, 18:00:17)
    Parece que é preciso um tempo depois do comando para que a mensagem chegue...
    Se a mensagem for a última de um script, por exemplo, parece que o script finaliza antes da mensagem chegar, não tenho certeza...
    Coloquei um timer de 1s (no scriptEngine) antes do script finilizar. Parece que resolve o problema. 

✔ Corrigir o nome da dolar por dollar (que meeerda) @low (Talvez eu deixe assim mesmo...) @done (04/10/2025, 17:58:02)

✔ @critical  Corrigir o erro do listen @done (04/10/2025, 21:10:52)

✔ Implementar no PARSER a função que processa o XML após a validação e insere os valores default e fixed no script XML. @low @done (23/09/2025, 20:09:10)

    Obsservação:
        O processo de validação de um XML contra um XSD (XML Schema) geralmente apenas verifica se o documento está em conformidade.
        Ele retorna True (válido) ou False (inválido), mas não modifica a árvore de elementos do XML na memória.
        Os valores default e fixed definidos no XSD são, na verdade, diretivas para a lógica da sua aplicação, e não para o próprio validador.
        Se um atributo com um valor default não estiver presente no seu arquivo XML, ele não será automaticamente adicionado ao objeto Python que representa o XML.
        

    Para usar o valor default, seu programa precisa seguir um fluxo de processamento mais explícito:

    1. Ler o XML de Instância:
        Parsear o arquivo XML como ele é.

    2. Validar o XML:
        Validar a instância contra o XSD para garantir que a estrutura está correta.

    3. Ler o XML Schema (XSD):
        Parsear o próprio arquivo XSD.

    4. Processamento Lógico:
        Percorrer a árvore do XML de instância e, para cada atributo esperado que esteja ausente,
        buscar o seu valor default na representação em memória do XSD e adicioná-lo ao objeto XML na memória.

    * A biblioteca lxml (que não é embutida no Python, mas é a mais recomendada para esse tipo de tarefa)
    facilita bastante esse processo, pois ela lida muito bem tanto com o parsing do XML quanto com a validação do XSD.
    * Em resumo, o valor default é um contrato entre o designer do schema e o desenvolvedor da aplicação.
    É responsabilidade do desenvolvedor implementar a lógica que honra esse contrato, adicionando o valor quando ele está ausente.



